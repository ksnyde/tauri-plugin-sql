{"version":3,"sources":["../webview-src/index.ts"],"sourcesContent":["import { invoke } from '@tauri-apps/api/tauri'\n\nexport interface QueryResult {\n  /** the number of rows affected by the query. */\n  rowsAffected: number\n  /**\n   * The last inserted `id`.\n   *\n   * This value is always `0` when using the Postgres driver. If the\n   * last inserted id is required on Postgres, the `select` function\n   * must be used, with a `RETURNING` clause\n   * (`INSERT INTO todos (title) VALUES ($1) RETURNING id`).\n   */\n  lastInsertId: number\n}\n\n/**\n * **Database**\n *\n * the database class serves as the primary interface for the frontend\n * to communicate to the backend's `tauri-plugin-sql` API.\n */\nexport default class Database {\n  path: string\n  constructor(path: string) {\n    this.path = path\n  }\n\n  /**\n   * **load**\n   *\n   * A static initializer which connects to the underlying database\n   * and returns a `Database` instance once a connecion to the database\n   * is established.\n   * \n   * # Sqlite\n   * \n   * The path is relative to `tauri::api::path::BaseDirectory::App` and must start with `sqlite:`.\n   * \n   * ```ts\n   * const db = await Database.load(\"sqlite:test.db\");\n   * ```\n   */\n  static async load(path: string): Promise<Database> {\n    return await invoke<string>('plugin:sql|load', {\n      db: path\n    }).then((p) => new Database(p))\n  }\n\n  /**\n   * **get**\n   *\n   * A static initializer which synchronously returns an instance of\n   * the Database class while deferring the actual database connection\n   * until the first invokation or selection on the database.\n   * \n   * # Sqlite\n   * \n   * The path is relative to `tauri::api::path::BaseDirectory::App` and must start with `sqlite:`.\n   *\n   * ```ts\n   * const db = Database.get(\"sqlite:test.db\");\n   * ```\n   */\n  static get(path: string): Database {\n    return new Database(path)\n  }\n\n  /**\n   * **execute**\n   *\n   * Passes a SQL expression to the database for execution.\n   *\n   * ```ts\n   * const result = await db.execute(\n   *    \"UPDATE todos SET title = $1, completed = $2 WHERE id = $3\",\n   *    [ todos.title, todos.status, todos.id ]\n   * );\n   * ```\n   */\n  async execute(query: string, bindValues?: any[]): Promise<QueryResult> {\n    return await invoke<[number, number]>('plugin:sql|execute', {\n      db: this.path,\n      query,\n      values: bindValues ?? []\n    }).then(([rowsAffected, lastInsertId]) => ({ rowsAffected, lastInsertId }))\n  }\n\n  /**\n   * **select**\n   *\n   * Passes in a SELECT query to the database for execution.\n   *\n   * ```ts\n   * const result = await db.select(\n   *    \"SELECT * from todos WHERE id = $1\", id\n   * );\n   * ```\n   */\n  async select<T>(query: string, bindValues?: any[]): Promise<T> {\n    return await invoke('plugin:sql|select', {\n      db: this.path,\n      query,\n      values: bindValues ?? []\n    })\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA,mBAAuB;AAsBvB,qBAA8B;AAAA,EAE5B,YAAY,MAAc;AACxB,SAAK,OAAO;AAAA;AAAA,eAkBD,KAAK,MAAiC;AACjD,WAAO,MAAM,yBAAe,mBAAmB;AAAA,MAC7C,IAAI;AAAA,OACH,KAAK,CAAC,MAAM,IAAI,SAAS;AAAA;AAAA,SAkBvB,IAAI,MAAwB;AACjC,WAAO,IAAI,SAAS;AAAA;AAAA,QAehB,QAAQ,OAAe,YAA0C;AACrE,WAAO,MAAM,yBAAyB,sBAAsB;AAAA,MAC1D,IAAI,KAAK;AAAA,MACT;AAAA,MACA,QAAQ,kCAAc;AAAA,OACrB,KAAK,CAAC,CAAC,cAAc,kBAAmB,GAAE,cAAc;AAAA;AAAA,QAcvD,OAAU,OAAe,YAAgC;AAC7D,WAAO,MAAM,yBAAO,qBAAqB;AAAA,MACvC,IAAI,KAAK;AAAA,MACT;AAAA,MACA,QAAQ,kCAAc;AAAA;AAAA;AAAA;","names":[]}